\subsection{\hybrid}
Brings the two approaches together Each node generates its own
pseudonyms and signs them with a  Group Signature
• GS act as a self-generated certificate
Each pseudonym is used for a limited amount of time and then discarded o can be used to sign a limited amount of beacoms that 
can be fixed in a configuration file then discarded.
\\
How does it work?
For each new message to securize, the trasciever send first it at the security box, where the security scheme used is the Hybrid Scheme. This scheme conatians two mains functions : 
\begin{itemize}
\item Securize\\
Basically used to generate the secure payload to sent like the scheme provided in [2] the principals functionalities  added are :
 Integrity  :  we generate at each message  to sent a new pseudonym that will used to sign the message and the signature provided will be added to the payload. The generation of the key is perfomed by the bouncy castel  provider under openssl and the signature also by the same provider and using the ECPair generator.
Authentication : The pseudonym  is  certified , signed by the private  group key in other to authenticate the sender. But due to the complexity of the group signature algorithm the function to generate the self certify will be  dummy taking into account the different data provided by [2]: the signature time and the signature bytes size and both the key and the signature will put in one vector that will be consider as our certificate.\\
Finally the packet generated by the function securize will have the following structure:\\
    Packet id : 4 bytes in order to identify the signed packet.\\
   The payload needed data : 200 bytes \\
The signature on the payload : 69 bytes
The length of the signature in order to recover it form the final packet : 4 bytes
 The self certify of the pseudonym generated on the fly : 298 bytes
Total packet size represented as a vector of bytes is 570 bytes.
Privacy : the group signature works in other to avoid that some user can't be identity through a subsequent messages by it signed. And the id added to


\item Verify\\
The function verify specially check the integrity of the received message and the authenticity of the sender.
Is a Boolean function that receive from the transceiver a message already reconstructed in a class and can extract all additional  information added in the securize  function in order to run the verification .
Form these information like the signature performed on the message , the pseudonym  used to signed the message and the self certificate , the verify check  the received message and return true or false in order in the checking is right or wrong.

\item Optimization\\
We can note in the securize part  that the size of the message sent is 570 respect to the size of the payload that contain the useful information , the overhead here is 370. One of the improvement we did here were to try to reduce that overhead keeping always the security level . The technique implemented  here is base on the  optimization 1\&2 provided by [2]. For each new message sent we set some timer correspond to the life time of the pseudonym generated .This reduce the computational time needed to recomputed that pseudonym and the self certificate this for a time correspond at the one set by the timer . We have defined also a  counter for the number of messages sent using the same pseudonym, this allow us to don't need to attach the self certify for a given  number of messages set by the counter and will reduce for about 298 bytes the size of the message sent.\\
At the verification we choose to verify first the size of the received message  that allow us to check if or not the certificate where attached at the sender  and we decide or not  to skip the authentication.\\ 
The counter value and the timer value can be set  in the configuration file.

\end{itemize}


